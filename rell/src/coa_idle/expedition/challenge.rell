struct module_args {
    travel_time: integer;
}

val TRAVEL_TIME = chain_context.args.travel_time;

namespace Challenge {
    enum e_type {
        fight,
        check
    }

    enum e_terrain {
        savannah,
        forrest,
        lava,
        village,
        max
    }

    enum e_difficulty {
        normal,
        hard,
        boss
    }

    enum e_state {
        selectable,
        ignored,
        traveling,
        skipped,
        resolved,
        retreated,
        perished
    }

    enum e_action {
        resolve,
        skip
    }

    entity __def {
        id: byte_array;
        level: integer;
        expedition: Expedition.__def;
        e_type;
        e_difficulty;
        e_terrain;
        class_advantage: Hero.e_class;

        key id;
    }

    entity arrival_time {
        key challenge: __def;
        timestamp;
    }

    entity state {
        challenge: __def;
        state: e_state;
        created_at: timestamp;
        
        key challenge, state;
    }

    entity effect {
        challenge: __def;
        consumable: Consumable.e_type;
    }

    entity outcome {
        key challenge: __def;
        hero_id: byte_array;
        damage: integer;
        needed: integer;
        roll: integer;
        success: boolean;
    }

    entity cancel {
        expedition: Expedition.__def;
        timestamp;
    }

    function get(id: byte_array) {
        return __def @ {id};
    }

    function get_active(expedition: Expedition.__def) {
        val challenge = state @ {
            .challenge.expedition == expedition, 
            .state == e_state.traveling
        } (@omit @sort_desc .challenge.level, .challenge) limit 1;
        
        return if (get_latest_state(challenge) == e_state.traveling) challenge else null;
    }

    function get_overview(challenge: __def) {
        return (
            id = challenge.id,
            level = challenge.level,
            type = challenge.e_type,
            difficulty = challenge.e_difficulty,
            terrain = challenge.e_terrain
        );
    }

    function get_definition(challenge: __def) {
        return (
            id = challenge.id,
            level = challenge.level,
            type = challenge.e_type,
            difficulty = challenge.e_difficulty,
            terrain = challenge.e_terrain,
            states = get_states_definition(challenge),
            outcome = get_outcome_definition(challenge),
            loot = ChallengeLoot.get_definition(challenge)
        );
    }

    function get_all(expedition: Expedition.__def) {
        return (c: __def) @ {expedition} (
            @omit @sort_desc .rowid,
            id = .id,
            level = .level,
            type = .e_type,
            difficulty = .e_difficulty,
            terrain = .e_terrain,
            states = get_states_definition(c),
            outcome = get_outcome_definition(c)
        );
    }

    function get_states_definition(challenge: __def) {
        return state @* {challenge} (
            state = .state.name,
            @sort_desc created_at = .created_at
        );
    }

    function get_outcome_definition(challenge: __def) {
        return outcome @* {challenge} (
            hero_id = .hero_id,
            damage = .damage,
            needed = .needed,
            roll = .roll,
            success = .success
        );
    }

    function get_latest_state(challenge: __def) {
        return state @ {challenge} (@omit @sort_desc .created_at, .state) limit 1;
    }

    function get_arrival(challenge: __def) {
        return arrival_time @ {challenge}.timestamp;
    }

    function get_retreat(expedition: Expedition.__def) {
        return cancel @ {expedition}.timestamp;
    }

    function select_challenge(challenge: __def) {
        var latest_state = get_latest_state(challenge);
        require(latest_state == e_state.selectable);

        travel_to(challenge);
    }

    function select_action(challenge: __def, action: e_action, timestamp = now()) {
        var latest_state = get_latest_state(challenge);
        require(latest_state == e_state.traveling);
        require(get_arrival(challenge) <= timestamp);

        when (action) {
            e_action.resolve -> resolve(challenge);
            e_action.skip -> skip(challenge);
        }

        if (not ExpeditionParty.is_wiped(challenge.expedition)) {
            next(challenge.expedition, challenge.level);
        } else {
            set_perished(challenge);            
            ChallengeLoot.on_wipe(challenge);
            ExpeditionConsumables.on_wipe(challenge.expedition);
            create cancel (challenge.expedition, now());
        }
    }

    function resolve(challenge: __def, chance_in: integer? = null) {
        set_resolved(challenge);

        var party = ExpeditionParty.get(challenge.expedition);

        var chance = if (chance_in??) chance_in else CHALLENGE_SUCCESS_CHANCE()[challenge.e_difficulty];
        if (party @ {.hero.e_class == challenge.class_advantage, .health > 0} (@sum 1) > 0)
            chance += BONUS_MATCH_CLASS; 

        val effects = effect @* {challenge};
        for (effect in effects) {
            val e = Consumable.EFFECT_MAPPING()[effect.consumable];
            if (effect.consumable.name.starts_with("strength_potion")) {
                chance += e;
            }
        }

        val species_favor = SPECIES_FAVOR()[challenge.e_terrain];
        val alive_members = party @* {.health > 0};
        for (member in party) {
            var rnd = Random.next_integer(100) + 1;
            val hero_chance = if (member.hero.e_species == species_favor) chance + BONUS_MATCH_SPECIES else chance;
            var damage = DAMAGE_MAP()[challenge.e_difficulty][challenge.expedition.e_danger_level];
            val success = rnd > hero_chance;
            damage = if (success) damage else (damage * 0.2).to_integer();

            if (member.health > 0) {
                member.health = max(0, member.health - damage);
            } else {
                for (alive_member in alive_members) {
                    alive_member.health = max(0, alive_member.health - (damage / alive_members.size()));
                }
            }

            create outcome (
                challenge,
                member.hero.id,
                damage,
                needed = hero_chance,
                roll = rnd,
                success
            );
        }

        ChallengeLoot.create_random(challenge);
    }

    function skip(challenge: __def) {
        set_skipped(challenge);
        var chance = CHALLENGE_SUCCESS_CHANCE()[challenge.e_difficulty];
        var rnd = Random.next_integer(100) + 1;
        if (rnd > chance)
            resolve(challenge, chance - BYPASS_MALUS);
    }
    
    function next(
        expedition: Expedition.__def,
        previous_level: integer = 0
    ) {
        val new_level = (previous_level % 10) + 1;
        val paths = if (new_level == 10) 1 else 2; // one path to boss
        if (previous_level == 10) // was in boss level -> increase difficulty
            Expedition.bump_difficulty(expedition);
        
        for (i in range(paths)) {
            var terrain = random_terrain();
            var challenge = create __def(
                (expedition.id, new_level, i).hash(),
                new_level,
                random_type(),
                terrain,
                DIFFICULTY_MAP()[new_level],
                Hero.get_random_class(),
                expedition
            );
            set_selectable(challenge);
        }
    }

    function retreat(expedition: Expedition.__def) {
        require(cancel @? {expedition} == null);

        val latest_level = __def @ {expedition} (@group @sort_desc .level) limit 1;
        val latest_challenges = __def @* {expedition, .level == latest_level};

        for (challenge in latest_challenges)
            set_retreated(challenge);

        create cancel (expedition, now());
    }

    // +++++++++++++++++
    // RANDOM
    // +++++++++++++++++
    function random_type() {
        var chances = CHALLENGE_CHANCE();
        var chances_max = chances @ {} (@sum $[1]);
        
        var rnd = Random.next_integer(chances_max)+1;
        var idx = 0;
        while (true) {
            rnd -= chances[e_type.value(idx)];
            if (rnd <= 0)
                break;
            else
                idx++;
        }

        return e_type.value(idx);
    }

    function random_terrain() {
        return e_terrain.value(Random.next_integer(e_terrain.max.value));
    }
    // +++++++++++++++++

    // +++++++++++++++++
    // STATE  UPDATES
    // +++++++++++++++++
    function travel_to(challenge: __def) {
        val now = now();
        val ignored_challenges = state @* {
            .challenge.expedition == challenge.expedition,
            .challenge.level == challenge.level,
            .challenge != challenge
        }.challenge;
        for (ignored_challenge in ignored_challenges)
            create state (ignored_challenge, e_state.ignored, now);
        
        create state (challenge, e_state.traveling, now);
        create arrival_time (challenge, now + TRAVEL_TIME);
    }

    function set_resolved(challenge: __def) {
        create state (challenge, e_state.resolved, now());
    }

    function set_skipped(challenge: __def) {
        create state (challenge, e_state.skipped, now());
    }

    function set_perished(challenge: __def) {
        create state (challenge, e_state.perished, now());
    }

    function set_selectable(challenge: __def) {
        create state (challenge, e_state.selectable, now());
    }

    function set_retreated(challenge: __def) {
        create state (challenge, e_state.retreated, now());
    }
    // +++++++++++++++++

    // +++++++++++++++++
    // GLOBALS
    // +++++++++++++++++
    val BONUS_MATCH_CLASS = 25;
    val BONUS_MATCH_SPECIES = 5;
    val BYPASS_MALUS = 15;

    function CHALLENGE_CHANCE() = map<e_type, integer>([
        e_type.fight: 100,
        e_type.check: 100
    ]);

    function SPECIES_FAVOR() = map<e_terrain, Hero.e_species>([
        e_terrain.village: Hero.e_species.human,
        e_terrain.savannah: Hero.e_species.leo,
        e_terrain.forrest: Hero.e_species.elve,
        e_terrain.lava: Hero.e_species.draco
    ]);

    function CHALLENGE_SUCCESS_CHANCE() = map<e_difficulty, integer>([
        e_difficulty.normal: 60,
        e_difficulty.hard: 50,
        e_difficulty.boss: 40
    ]);

    function DAMAGE_MAP() = map<e_difficulty, map<Expedition.e_danger_level, integer>>([
        e_difficulty.normal: [
            Expedition.e_danger_level.neglible: 15,
            Expedition.e_danger_level.harmless: 20,
            Expedition.e_danger_level.unhealthy: 30,
            Expedition.e_danger_level.interesting: 45,
            Expedition.e_danger_level.seriously: 60
        ],
        e_difficulty.hard: [
            Expedition.e_danger_level.neglible: 30,
            Expedition.e_danger_level.harmless: 40,
            Expedition.e_danger_level.unhealthy: 60,
            Expedition.e_danger_level.interesting: 90,
            Expedition.e_danger_level.seriously: 120
        ],
        e_difficulty.boss: [
            Expedition.e_danger_level.neglible: 60,
            Expedition.e_danger_level.harmless: 80,
            Expedition.e_danger_level.unhealthy: 120,
            Expedition.e_danger_level.interesting: 180,
            Expedition.e_danger_level.seriously: 240
        ]
    ]);
    
    function DIFFICULTY_MAP() = list<e_difficulty>([
        e_difficulty.normal,
        e_difficulty.normal,
        e_difficulty.normal,
        e_difficulty.hard,
        e_difficulty.normal,
        e_difficulty.normal,
        e_difficulty.hard,
        e_difficulty.normal,
        e_difficulty.hard,
        e_difficulty.boss
        // Expedition.e_danger_level.neglible: [
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.hard,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.boss
        // ],
        // Expedition.e_danger_level.harmless: [
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.hard,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.boss
        // ],
        // Expedition.e_danger_level.unhealthy: [
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.hard,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.hard,
        //     e_difficulty.normal,
        //     e_difficulty.hard,
        //     e_difficulty.boss
        // ],
        // Expedition.e_danger_level.interesting: [
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.hard,
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.hard,
        //     e_difficulty.normal,
        //     e_difficulty.hard,
        //     e_difficulty.boss
        // ],
        // Expedition.e_danger_level.seriously: [
        //     e_difficulty.normal,
        //     e_difficulty.normal,
        //     e_difficulty.hard,
        //     e_difficulty.normal,
        //     e_difficulty.hard,
        //     e_difficulty.normal,
        //     e_difficulty.hard,
        //     e_difficulty.hard,
        //     e_difficulty.hard,
        //     e_difficulty.boss
        // ]
    ]);
    // +++++++++++++++++
}

namespace ChallengeLoot {
    enum e_state {
        open,
        claimed,
        lost,
        dropped
    }

    entity __def {
        challenge: Challenge.__def;
        e_type;
        name;
        amount: integer;
        mutable state: e_state = e_state.open;
    }

    enum e_type {
        artifact,
        consumable,
        shards
    }

    function construct(
        challenge: Challenge.__def,
        name,
        e_type,
        amount: integer
    ) {
        return create __def (challenge, name, e_type, amount);
    }

    function get_definition(challenge: Challenge.__def) {
        return __def @* {challenge} (
            type = .e_type.name,
            amount = .amount,
            state = .state.name
        );
    }

    function create_random(challenge: Challenge.__def) {
        var amount = SHARD_REWARDS()[challenge.e_difficulty];
        // TODO multiplied by level and danger
        construct(challenge, "shards", e_type.shards, amount);

        val spaces = Backpack.get_space(challenge.expedition.backpack_rarity);
        var consumable_space = ExpeditionConsumables.__def @ {challenge.expedition} (@sum 1);
        var loot_space = __def @ {challenge, e_type.artifact} (@sum 1);

        drop_consumables(challenge, spaces.consumable, consumable_space);
    }

    function drop_consumables(challenge: Challenge.__def, space: integer, filled: integer) {
        val chance_map = CONSUMALBE_REWARD_CHANCE()[challenge.e_difficulty];
        for (i in range(MAX_ROLLS)) {
            val rnd = Random.next_integer(100) + 1;
            if (rnd > chance_map[i]) {
                val consumable = CONSUMALBE_DROP_POOL()[Random.next_integer(CONSUMALBE_DROP_POOL().size())];
                val e = construct(challenge, consumable.name, e_type.consumable, 1);
                if (filled < space) {
                    ExpeditionConsumables.construct(challenge.expedition, consumable);
                    e.state = e_state.claimed;
                } else {
                    e.state = e_state.dropped;
                }
            }
        }
    }

    function drop_loot(challenge: Challenge.__def, space: integer, filled: integer) {
        val chance_map = LOOT_REWARD_CHANCE()[challenge.e_difficulty];        
        for (i in range(MAX_ROLLS)) {
            val rnd = Random.next_integer(100) + 1;
            if (rnd > chance_map[i]) {
                val consumable = CONSUMALBE_DROP_POOL()[Random.next_integer(CONSUMALBE_DROP_POOL().size())];

                // TODO define how and which artifact to drop

                val e = construct(challenge, consumable.name, e_type.artifact, 1);
                if (filled < space) {
                    e.state = e_state.dropped;
                }
            }
        }
    }

    function claim(expedition: Expedition.__def) {
        val shards = __def @ {.challenge.expedition == expedition, .e_type == e_type.shards, .state == e_state.open} (@sum .amount);
        Player.give_shards(expedition.player, shards);

        val rest =  __def @* {.challenge.expedition == expedition, .e_type != e_type.shards, .state == e_state.open};
        for (item in rest) {
            val artifact = Artifact.get(item.name);
            Player.give_shards(expedition.player, artifact.price);
        }

        update __def @* {.challenge.expedition == expedition, .state != e_state.open} (.state = e_state.claimed);
    }

    function on_wipe(challenge: Challenge.__def) {
        update __def @* {.challenge.expedition == challenge.expedition, .e_type != e_type.shards, .state == e_state.open} (.state = e_state.lost);
        var shards = __def @* {.challenge.expedition == challenge.expedition, .e_type == e_type.shards, .state == e_state.open};
        var rest_amount = 0;
        for (shard in shards) {
            shard.state = e_state.lost;
            rest_amount += shard.amount/2;
        }
        construct(challenge, "shards", e_type.shards, rest_amount);
    }

    // +++++++++++++++++
    // GLOBALS
    // +++++++++++++++++
    val MAX_ROLLS = 2;

    function LOOT_REWARD_CHANCE() = map<Challenge.e_difficulty, list<integer>>([
        Challenge.e_difficulty.normal: [0, 0],
        Challenge.e_difficulty.hard: [75, 0],
        Challenge.e_difficulty.boss: [100, 50]
    ]);

    function CONSUMALBE_REWARD_CHANCE() = map<Challenge.e_difficulty, list<integer>>([
        Challenge.e_difficulty.normal: [10, 0],
        Challenge.e_difficulty.hard: [25, 0],
        Challenge.e_difficulty.boss: [100, 0]
    ]);

    function CONSUMALBE_DROP_POOL() = list<Consumable.e_type>([
        Consumable.e_type.health_potion_l
        // TODO fill the rest
    ]);
    
    function SHARD_REWARDS() = map<Challenge.e_difficulty, integer>([
        Challenge.e_difficulty.normal: 50,
        Challenge.e_difficulty.hard: 200,
        Challenge.e_difficulty.boss: 1000
    ]);

    function LOOT_RARITY_CHANCE() = map<Hero.e_rarity, integer>([
        Hero.e_rarity.common: 10,
        Hero.e_rarity.uncommon: 25,
        Hero.e_rarity.rare: 35,
        Hero.e_rarity.magical: 75,
        Hero.e_rarity.legendary: 100
    ]);
    // +++++++++++++++++
}
