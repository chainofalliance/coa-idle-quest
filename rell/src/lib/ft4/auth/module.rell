@mount('ft4')
module;

import ^.accounts;

struct auth_data {
    flags: list<text>;
    message: text;
}

struct _auth_handler {
    flags: list<text>;
    message_formatter: ((gtv) -> text)? = null;
}

/*
 * The constant that defines app level authentication scope.
 * If scope is omitted when defining an auth handler, then
 * it has 'app' scope, i.e. it is used to authenticate 
 * operations that do not have own auth handlers or if 
 * there is no mount point auth handler for the operation.
 */
val APP_SCOPE = "app";

/*
 * Extendable function used to define auth handlers. 
 * When called it returns a list of all auth handlers defined
 * in the dapp.
 */
@extendable 
function auth_handler(): map<name, _auth_handler>;

/*
 * Finds auth handler for provided operation name.
 */
function get_auth_handler(op_name: name) {
    require_valid_scope_name(op_name);
    val auth_handlers = auth_handler();
    if (op_name in auth_handlers) return auth_handlers[op_name];

    val handler = get_mount_scope_auth_handler(auth_handlers, op_name);
    if (handler??) return handler;

    return require(
        auth_handlers.get_or_null(APP_SCOPE), 
        "Cannot find auth handler for operation <%s>".format(op_name)
    );
}

function add_auth_handler(scope: text = APP_SCOPE, flags: list<text>, message: ((gtv) -> text)? = null) {
    val scope_name = scope.trim();
    require_valid_scope_name(scope_name);
    return [scope_name: _auth_handler(flags, message)];
}

function args() = op_context.get_all_operations()[op_context.op_index].args.to_gtv();

struct signature {
    r: byte_array;
    s: byte_array;
    v: integer;
}

function get_mount_scope_auth_handler(auth_handlers: map<name, _auth_handler>, op_name: name) {
    val op_name_components = op_name.split(".");
    if (op_name_components.size() < 2) return null;
    
    for (count in range(op_name_components.size()-1, 0, -1)) {
        val mount_point = join_text_list(op_name_components, count);
        if (mount_point in auth_handlers) return auth_handlers[mount_point];
    }

    return null;
}

/*
 * Creates message from operation name and arguments.
 * It is used when `evm_auth`Â is used to authenticate a user, 
 * but auth message is not specified in the auth handler of the operation.
 */
function generate_auth_message_template(brid: byte_array, op: gtx_operation) {
    var message = "Please sign the message to call\noperation:\n- %s\n\n".format(op.name);

    if (op.args.size() > 0) {
        var arguments = "with arguments:\n";
        for (arg in op.args) {
            arguments = arguments + "- %s\n".format(arg).replace("\"", "");
        }
        message = message + arguments + "\n";
    }
    
    return message + "Nonce: {nonce}";
}

function join_text_list(components: list<text>, count: integer) {
    require(count < components.size() and count > 0, "Error building mount path");
    var result = components[0];
    for (i in range(1, count)) {
        result = result + "." + components[i];
    }
    return result;
}

function require_valid_scope_name(name) =     
    require(
        name.matches("^\\w+(\\.\\w+)*$"), 
        "Invalid scope name <%s>".format(name)
    );
